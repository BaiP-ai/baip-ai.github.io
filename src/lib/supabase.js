import { createClient } from '@supabase/supabase-js';

// These lines read from your .env file via Astro/Vite's import.meta.env
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Check if the variables are loaded correctly AND LOG THEM
if (!supabaseUrl || !supabaseAnonKey) {
  console.error("Supabase URL or Anon Key is missing. Check your .env file.");
} else {
  console.log("Supabase Initializing with URL:", supabaseUrl);
  console.log("Supabase Key starts with:", supabaseAnonKey.substring(0, 10) + "...");
  console.log("Key appears to be valid JWT format:", supabaseAnonKey.startsWith("eyJ"));
}

// Create client with explicit options for proper authentication
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  },
  global: {
    headers: {
      'apikey': supabaseAnonKey,
      'Authorization': `Bearer ${supabaseAnonKey}`
    }
  }
});

// Simplified test function to just check connection without requiring tables
export const testSupabaseConnection = async () => {
  try {
    console.log("Testing Supabase connection...");
    
    // Just test the basic connection first
    const response = await fetch(`${supabaseUrl}/rest/v1/`, {
      method: 'GET',
      headers: {
        'apikey': supabaseAnonKey,
        'Authorization': `Bearer ${supabaseAnonKey}`
      }
    });
    
    console.log("API connection response:", response.status, response.statusText);
    if (!response.ok) {
      return { 
        success: false, 
        error: { 
          message: `API connection failed: ${response.status} ${response.statusText}`,
          status: response.status
        } 
      };
    }
    
    // Try to list all tables to see what's available
    console.log("Checking available tables...");
    const { data: tableList, error: tableError } = await supabase
      .rpc('get_tables');  // This is a built-in function
      
    if (tableError) {
      console.error("Could not get table list:", tableError);
    } else {
      console.log("Available tables:", tableList);
    }
    
    return { success: true, data: { message: "Connection successful" } };
  } catch (e) {
    console.error("Unexpected error in connection test:", e);
    return { success: false, error: { message: e.message, details: e } };
  }
};

// Function to check if contact_messages table exists and create it if needed
export const setupContactTable = async () => {
  try {
    // Execute our table creation SQL via RPC
    const { data, error } = await supabase.rpc('exec_sql', { 
      sql_string: `
        -- Create the table if it doesn't exist
        CREATE TABLE IF NOT EXISTS public.contact_messages (
          id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
          name text,
          email text NOT NULL,
          company text,
          message text NOT NULL,
          status text DEFAULT 'new'::text,
          admin_reply text
        );
        
        -- OPTION 1: DISABLE ROW LEVEL SECURITY COMPLETELY (for testing)
        ALTER TABLE public.contact_messages DISABLE ROW LEVEL SECURITY;
        
        -- Remove any existing policies for a clean slate
        DROP POLICY IF EXISTS "Allow public insert access" ON public.contact_messages;
        DROP POLICY IF EXISTS "Allow anon insert access" ON public.contact_messages;
        DROP POLICY IF EXISTS "Allow ALL inserts" ON public.contact_messages;
        
        -- Grant all necessary permissions
        GRANT ALL ON TABLE public.contact_messages TO public, anon;
      `
    });
    
    if (error) {
      console.error("Error setting up table:", error);
      return { success: false, error };
    }
    
    console.log("Table setup result:", data);
    return { success: true, data };
  } catch (e) {
    console.error("Exception setting up table:", e);
    return { success: false, error: e };
  }
};

// Alternative setup function that ENABLES RLS with policy (if the above doesn't work)
export const setupContactTableWithRLS = async () => {
  try {
    const { data, error } = await supabase.rpc('exec_sql', { 
      sql_string: `
        -- Create the table if it doesn't exist
        CREATE TABLE IF NOT EXISTS public.contact_messages (
          id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
          name text,
          email text NOT NULL,
          company text,
          message text NOT NULL,
          status text DEFAULT 'new'::text,
          admin_reply text
        );
        
        -- Enable RLS
        ALTER TABLE public.contact_messages ENABLE ROW LEVEL SECURITY;
        
        -- Remove any existing policies
        DROP POLICY IF EXISTS "Allow public insert access" ON public.contact_messages;
        DROP POLICY IF EXISTS "Allow anon insert access" ON public.contact_messages;
        DROP POLICY IF EXISTS "Allow ALL inserts" ON public.contact_messages;
        
        -- Create a very permissive policy for INSERT
        CREATE POLICY "Allow ALL inserts" ON public.contact_messages
          FOR INSERT
          TO public
          WITH CHECK (true);
          
        -- Grant all permissions
        GRANT ALL ON TABLE public.contact_messages TO public, anon;
        
        -- Verify if inserted rows are visible for the role
        CREATE POLICY "Allow read own rows" ON public.contact_messages
          FOR SELECT
          TO public
          USING (true);
      `
    });
    
    if (error) {
      return { success: false, error };
    }
    
    return { success: true, data };
  } catch (e) {
    return { success: false, error: e };
  }
};

// For production, you have two options:

// OPTION 1: Keep RLS disabled (less secure but functional)
// export const setupContactTable = async () => {
//   ...existing code...
// };

// OPTION 2: If you need security later, try to diagnose the RLS policy issue 
// with Supabase support using the setupContactTableWithRLS() function

export const submitContactForm = async (formData) => {
  if (!formData.email || !formData.message) {
    console.error("Form data missing required fields:", formData);
    throw new Error("Email and Message are required.");
  }

  const { data, error } = await supabase
    .from('contact_messages')
    .insert([
      { 
        name: formData.name || null, 
        email: formData.email, 
        company: formData.company || null, 
        message: formData.message,
        status: 'new' 
      }
    ])
    .select();

  if (error) {
    console.error("Supabase insert error:", error);
    console.error("Supabase error code:", error.code);
    const message = error.message || "Failed to send message. Please check console for details.";
    throw new Error(message);
  }

  console.log("Supabase insert success:", data);
  return data;
};
